codeunit 8800 "Custom Layout Reporting"
{
    // version NAVW113.00

    // This codeunit implements batch printing and custom layout association on a per-object basis.
    // Reports may be based on one table, but we may want to sepcific a layout per-customer, or per-vendor.
    // This codeunit provides functions to help manage the association between the table that backs the report and the object we want custom layouts on.
    // 
    // Example code below, for Customer Statements, backed by Customer and associating custom reports per-Customer:
    // 
    // // Get the RecordRef of the table that will source the data for our report - Statements should be backed by Customer
    // RecRef.OPEN(DATABASE::Customer);
    // // Set up the association between the Table that is the source of the report and the association to the table we want layouts for
    // // In this case, we are using Customer for the report and Customer for the layouts.
    // CustomerLayoutReporting.ProcessReport(ReportSelections.Usage::"C.Statement",RecRef,'No.',DATABASE::Customer,'No.',TRUE);


    trigger OnRun()
    begin
    end;

    var
        TempBlobReqParamStore: Record TempBlob temporary;
        ReportSelections: Record "Report Selections";
        CustomReportSelection: Record "Custom Report Selection";
        ReportLayoutSelection: Record "Report Layout Selection";
        TempNameValueBuffer: Record "Name/Value Buffer" temporary;
        TempEmailNameValueBuffer: Record "Name/Value Buffer" temporary;
        TempEraseFileNameValueBuffer: Record "Name/Value Buffer" temporary;
        RequestPageParametersHelper: Codeunit "Request Page Parameters Helper";
        FileManagement: Codeunit "File Management";
        ReportDataRecordRef: RecordRef;
        IteratorRecordRef: RecordRef;
        ReportDataIteratorFieldRef: FieldRef;
        IteratorJoinFieldRef: FieldRef;
        BalAcctTypeFieldRef: FieldRef;
        AcctTypeFieldRef: FieldRef;
        OutputType: Option Print,Preview,PDF,Email,Excel,Word,XML;
        SaveFolderMsg: Label 'Select a folder to save reports to.';
        NotInitializedErr: Label 'Report data not initialized.';
        OutputNotSupportedErr: Label 'The chosen output method is not supported.';
        SMTPNotSetupErr: Label 'To send as email, you must set up SMTP.';
        ReportingType: Option "Object","Layout";
        ZipFileName: Text;
        ZipDownloadTxt: Label 'AllReports.zip';
        Path: Text;
        OutputFileBaseName: Text;
        Initialized: Boolean;
        ReportDataAndIteratorDiffer: Boolean;
        SupressOutput: Boolean;
        PrintRemaining: Boolean;
        OverrideOutput: Boolean;
        TestModeWebClient: Boolean;
        PathLengthErr: Label 'The file name %1 is too long and cannot be used.', Comment='%1: a file name, generated by the system';
        ReportFormatNotSupportedErr: Label 'Creation of report with format type %1 is not supported.', Comment='%1 is the extension for the report.';
        NoOutputErr: Label 'No data exists for the specified report filters.';
        AnyOutputExists: Boolean;
        LastUsedTxt: Label 'Last used options and filters', Comment='Translation must match RequestPageLatestSavedSettingsName from Lang.resx';

    [Scope('Personalization')]
    procedure GetLayoutIteratorKeyFilter(var FilterRecordRef: RecordRef;var FilterRecordKeyFieldRef: FieldRef;CustomReportLayoutCode: Code[20])
    var
        CustomReportSelection2: Record "Custom Report Selection";
        "Filter": Text;
    begin
        // Further filters the items in FilterRecordRef by restricting them only to items who have entries in the "* Report Selection" tables
        // This prevents us from iterating over items that aren't related to the custom layouts
        CustomReportSelection2.SetView(CustomReportSelection.GetView);

        // Set the filters on the "* Report Selection" table and iterate through
        CustomReportSelection2.SetRange("Custom Report Layout Code",CustomReportLayoutCode);

        if CustomReportSelection2.FindSet then
          repeat
            if Filter <> '' then
              Filter := Filter + '|';
            Filter := StrSubstNo('%1%2',Filter,CustomReportSelection2."Source No.");
          until CustomReportSelection2.Next = 0;

        // Set the more restrictive filter
        SetNextGroupFilter(FilterRecordRef,FilterRecordKeyFieldRef,Filter)
    end;

    procedure ProcessReport()
    var
        RequestPageParamsView: Text;
        FilterGroup: Integer;
        ReportProcFirstErrorText: Text;
    begin
        // If we're not yet initialized, exit - data needs to be set up before reports can be run
        if not Initialized then
          exit;

        ClearLastError;
        AnyOutputExists := true;
        // Iterate through the selections and run the reports.
        if ReportSelections.FindSet then begin
          AnyOutputExists := false;
          repeat
            SetOutputType(ReportSelections."Report ID");

            CustomReportSelection.SetFilter("Report ID",StrSubstNo('0|%1',ReportSelections."Report ID"));
            CustomReportSelection.SetRange(Usage,ReportSelections.Usage);

            PrintRemaining := false;

            // If our report's data item and the 'join table' are the same, then set its filter from the request page.
            if not ReportDataAndIteratorDiffer then begin
              RequestPageParamsView := GetViewFromParameters(ReportSelections."Report ID",IteratorRecordRef.Number);
              IteratorRecordRef.SetView(RequestPageParamsView);
            end;

            FilterGroup := ReportDataRecordRef.FilterGroup;
            ReportDataRecordRef.FilterGroup(FindNextEmptyFilterGroup(ReportDataRecordRef)); // Set the request page filters separately to preserve the existing filters
            RequestPageParamsView := GetViewFromParameters(ReportSelections."Report ID",ReportDataRecordRef.Number);
            ReportDataRecordRef.SetView(RequestPageParamsView);
            ReportDataRecordRef.FilterGroup(FilterGroup);
            case OutputType of
              OutputType::Email:
                begin
                  Evaluate(
                    PrintRemaining,GetOptionValueFromRequestPage(GetRequestParametersText(ReportSelections."Report ID"),'PrintRemaining'));
                  ProcessReportPerObject;
                end;
              OutputType::PDF,
              OutputType::Word,
              OutputType::Excel,
              OutputType::XML:
                ProcessReportPerObject;
              OutputType::Preview,
              OutputType::Print:
                ProcessReportPerLayout;
            end;
            if (ReportProcFirstErrorText = '') and (GetLastErrorText <> '') and (GetLastErrorText <> NoOutputErr) then
              ReportProcFirstErrorText := GetLastErrorText;
          until ReportSelections.Next = 0;
        end;

        // Download the .zip file containing the reports if one was generated (usually from being on the web client)
        if (ZipFileName <> '') and not SupressOutput and TempNameValueBuffer.FindSet then
          // If there's a single file, download it directly instead of the zip file
          if TempNameValueBuffer.Count = 1 then
            if IsTestMode then
              FileManagement.CopyServerFile(
                TempNameValueBuffer.Value,FileManagement.CombinePath(Path,TempNameValueBuffer.Name),true)
            else
              FileManagement.DownloadHandler(TempNameValueBuffer.Value,'','','',TempNameValueBuffer.Name)
          else begin
            repeat
              FileManagement.AddFileToZipArchive(TempNameValueBuffer.Value,TempNameValueBuffer.Name);
              TempEraseFileNameValueBuffer.AddNewEntry(TempNameValueBuffer.Value,'');
            until TempNameValueBuffer.Next = 0;
            FileManagement.CloseZipArchive;
            // If we're in test mode, save the zip to the save path. Otherwise send to the client.
            if IsTestMode then
              FileManagement.CopyServerFile(ZipFileName,FileManagement.CombinePath(Path,ZipDownloadTxt),true)
            else
              FileManagement.DownloadHandler(ZipFileName,'','','',ZipDownloadTxt);
          end;

        CleanupTempFiles;

        if not (SupressOutput or AnyOutputExists) then begin
          if ReportProcFirstErrorText <> '' then
            Error(ReportProcFirstErrorText);
          Error(NoOutputErr);
        end;
    end;

    procedure ProcessReportForData(ReportSelectionUsage: Integer;var DataRecordRef: RecordRef;SourceJoinFieldName: Text;DataRecordJoinTable: Integer;IteratorTableFieldName: Text;DataItemTableSameAsIterator: Boolean)
    begin
        // Provides a single function to run initialization code, check for issues, and start report processing
        if not Initialized then
          InitializeData(
            ReportSelectionUsage,DataRecordRef,SourceJoinFieldName,DataRecordJoinTable,IteratorTableFieldName,
            DataItemTableSameAsIterator);
        // If there was an error during initalization, exit
        if not Initialized then
          exit;
        ProcessReport;
    end;

    local procedure ProcessReportPerLayout()
    var
        ReportedLayouts: DotNet ArrayList;
        ReportedObjects: DotNet ArrayList;
        TempRecordRef: RecordRef;
        TempRecordKeyFieldRef: FieldRef;
        CustomReportLayoutCode: Code[20];
        ReportedRecordKeyVal: Text;
    begin
        ReportingType := ReportingType::Layout;
        // Prevent early calls to the function
        if not Initialized then
          Error(NotInitializedErr);

        // Temporary lists to keep track of what we've reported over, used to determine what to report on using the default layout
        ReportedLayouts := ReportedLayouts.ArrayList;
        ReportedObjects := ReportedObjects.ArrayList;

        // Iterate through the layouts in the Custom Report Selection table
        if CustomReportSelection.FindSet then begin
          repeat
            CustomReportLayoutCode := CustomReportSelection."Custom Report Layout Code";

            // Reset the TempRecordRef object
            TempRecordRef := ReportDataRecordRef.Duplicate;
            TempRecordKeyFieldRef := TempRecordRef.Field(ReportDataIteratorFieldRef.Number);

            // If we've not already reported on this layout and it truly is a custom layout, then report on it
            if not ReportedLayouts.Contains(CustomReportLayoutCode) and
               (ResolveCustomReportLayoutCode(CustomReportSelection) <> '')
            then begin
              ReportedLayouts.Add(CustomReportLayoutCode);

              // Run the report only for those objects that have this layout
              GetLayoutIteratorKeyFilter(TempRecordRef,TempRecordKeyFieldRef,CustomReportLayoutCode); // set view based on intersection of lists

              // Run the report on the data record, using the above filter
              RunReportWithCustomReportSelection(TempRecordRef,ReportSelections."Report ID",CustomReportSelection,PrintRemaining);

              // Save this list of objects reported on, using the 'iterator field', they will not get the default report layout later
              if TempRecordRef.FindFirst then
                repeat
                  ReportedRecordKeyVal := Format(TempRecordKeyFieldRef.Value);
                  if not ReportedObjects.Contains(ReportedRecordKeyVal) then
                    ReportedObjects.Add(ReportedRecordKeyVal);
                until TempRecordRef.Next = 0;
            end;
          until CustomReportSelection.Next = 0;
        end;

        // Construct the filter for the remaining objects - iterate through all items in the data record and build a filter that contains the
        // items that are not in the list of already reported items.
        TempRecordRef := ReportDataRecordRef.Duplicate;
        TempRecordKeyFieldRef := TempRecordRef.Field(ReportDataIteratorFieldRef.Number);

        // Set the exclusion filter based on the items we've already reported on and set that filter on top of the filter already applied
        if TempRecordRef.FindFirst then
          repeat
            if ReportedObjects.Contains(Format(TempRecordKeyFieldRef.Value)) then
              SetNextGroupFilter(TempRecordRef,TempRecordKeyFieldRef,StrSubstNo('<>%1',Format(TempRecordKeyFieldRef.Value)));
          until TempRecordRef.Next = 0;

        // Only run the report if we still have something to report on
        if TempRecordRef.FindFirst then
          RunReport(TempRecordRef,ReportSelections."Report ID",PrintRemaining);
    end;

    local procedure ProcessReportPerObject()
    var
        PrevRecordID: RecordID;
        IteratorJoinFieldValue: Code[20];
        ReportID: Integer;
        IteratorFilterGroup: Integer;
        JoinValue: Code[20];
    begin
        ReportingType := ReportingType::Object;
        if not Initialized then
          Error(NotInitializedErr);

        ReportID := ReportSelections."Report ID";

        Evaluate(IteratorJoinFieldValue,Format(IteratorJoinFieldRef.Value));

        // Set the data filter to be the item we're iterating over:

        if ReportDataRecordRef.FindSet then begin
          repeat
            // Get and set the report selection for this particular object/report combination
            JoinValue := Format(ReportDataIteratorFieldRef.Value,20);
            CustomReportSelection.SetRange("Source No.",JoinValue);
            IteratorFilterGroup := SetNextGroupFilter(ReportDataRecordRef,ReportDataIteratorFieldRef,JoinValue);
            PrevRecordID := ReportDataRecordRef.RecordId;

            SetIteratorJoinFieldRef;
            // Find the 'join' value in the associated table, this helps us generate the name
            IteratorJoinFieldRef.SetRange(JoinValue);
            IteratorRecordRef.FindFirst;

            // If the object has custom layouts defined - process each one based on the selected output type, otherwise use the default layout
            if CustomReportSelection.FindSet then
              repeat
                RunReportWithCustomReportSelection(ReportDataRecordRef,ReportID,CustomReportSelection,PrintRemaining);
              until CustomReportSelection.Next = 0
            else
              RunReport(ReportDataRecordRef,ReportID,PrintRemaining);

            // Clear out the filter and reset:
            SetGroupFilter(ReportDataRecordRef,ReportDataIteratorFieldRef,'',IteratorFilterGroup);
            ReportDataRecordRef.Get(PrevRecordID);

          until ReportDataRecordRef.Next = 0;
        end;
    end;

    local procedure RunReportWithCustomReportSelection(var DataRecRef: RecordRef;ReportID: Integer;var CustomReportSelection: Record "Custom Report Selection";EmailPrintRemaining: Boolean)
    var
        CustomReportLayoutCode: Code[20];
        EmailAddresses: Text;
    begin
        // Set the custom report layout
        CustomReportLayoutCode := ResolveCustomReportLayoutCode(CustomReportSelection);
        ReportLayoutSelection.SetTempLayoutSelected(CustomReportLayoutCode);

        // Get the email address of the current object-specific report selection
        EmailAddresses := CustomReportSelection."Send To Email";
        case OutputType of
          OutputType::Email:
            if EmailAddresses <> '' then
              EmailReport(DataRecRef,ReportID,CustomReportSelection)
            else
              if EmailPrintRemaining then
                PrintReport(DataRecRef,ReportID,CustomReportLayoutCode);
          OutputType::PDF:
            SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Pdf);
          OutputType::Excel:
            SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Excel);
          OutputType::Word:
            SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Word);
          OutputType::Print:
            PrintReport(DataRecRef,ReportID,CustomReportLayoutCode);
          OutputType::Preview:
            PreviewReport(DataRecRef,ReportID,CustomReportLayoutCode);
          OutputType::XML:
            SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Xml);
        end;
        if CustomReportLayoutCode <> '' then
          ReportLayoutSelection.SetTempLayoutSelected('');
    end;

    local procedure RunReport(var DataRecRef: RecordRef;ReportID: Integer;EmailPrintRemaining: Boolean)
    var
        NullCustomReportSelection: Record "Custom Report Selection";
    begin
        // If we know we don't need a custom report selection, e.g. we don't need layouts or won't be sending email
        NullCustomReportSelection.Init;
        RunReportWithCustomReportSelection(DataRecRef,ReportID,NullCustomReportSelection,EmailPrintRemaining);
    end;

    [Scope('Personalization')]
    procedure SetOutputOption(OutputOption: Integer)
    begin
        OutputType := OutputOption;
    end;

    procedure GetOutputOption(ReportID: Integer): Integer
    var
        OptionText: Text;
        OptionInt: Integer;
    begin
        // Given a report ID, get the currently selected output option
        OptionText := GetOptionValueFromRequestPageForReport(ReportID,'ChosenOutputMethod');
        if Evaluate(OptionInt,OptionText) then
          exit(OptionInt);

        exit(-1); // Invalid output option, still a valid return code - signals no output
    end;

    [Scope('Personalization')]
    procedure GetPrintOption(): Integer
    begin
        exit(OutputType::Print);
    end;

    [Scope('Personalization')]
    procedure GetEmailOption(): Integer
    begin
        exit(OutputType::Email);
    end;

    [Scope('Personalization')]
    procedure GetPreviewOption(): Integer
    begin
        exit(OutputType::Preview);
    end;

    [Scope('Personalization')]
    procedure GetExcelOption(): Integer
    begin
        exit(OutputType::Excel);
    end;

    [Scope('Personalization')]
    procedure GetPDFOption(): Integer
    begin
        exit(OutputType::PDF);
    end;

    [Scope('Personalization')]
    procedure GetWordOption(): Integer
    begin
        exit(OutputType::Word);
    end;

    [Scope('Personalization')]
    procedure GetXMLOption(): Integer
    begin
        exit(OutputType::XML);
    end;

    local procedure PrintReport(var DataRecRef: RecordRef;ReportID: Integer;CustomReportLayoutCode: Code[20])
    begin
        // If the print action is selected and we're on the web, shunt over to PDF output and ZIP file download
        if IsWebClient and not IsWordLayout(ReportID,CustomReportLayoutCode) then
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Pdf);

        // If we're on the web client, and Word layout, then run the default
        if IsWebClient and IsWordLayout(ReportID,CustomReportLayoutCode) then
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Word);

        // Local client - print
        if not IsWebClient and not SupressOutput then begin
          REPORT.Print(ReportID,GetRequestParametersText(ReportID),'',DataRecRef);
          AnyOutputExists := true;
        end;
    end;

    local procedure EmailReport(var DataRecRef: RecordRef;ReportID: Integer;CustomReportSelection: Record "Custom Report Selection")
    var
        FieldRef1: FieldRef;
        FieldRef2: FieldRef;
        ReportRecordVariant: Variant;
        TempPdfFilePath: Text[250];
        TempEmailBodyFilePath: Text[250];
        FileName: Text[250];
        PdfFileName: Text[250];
        TempReportLayoutCode: Code[20];
        EmailBodyLayoutCode: Code[20];
    begin
        TempPdfFilePath := CreateReportWithExtension(DataRecRef,ReportID,REPORTFORMAT::Pdf,FileName);
        if TempPdfFilePath = '' then
          exit;

        // Set the pdf file name to be used later when sending an email.
        PdfFileName := FileName;

        // Use the iterator values if the data item and iterator differ
        if ReportDataAndIteratorDiffer then begin
          GetKeyFieldRef(IteratorRecordRef,FieldRef1);
          GetNameFieldRef(IteratorRecordRef,FieldRef2);
        end else begin
          GetKeyFieldRef(DataRecRef,FieldRef1);
          GetNameFieldRef(DataRecRef,FieldRef2);
        end;

        EmailBodyLayoutCode := ResolveEmailBodyLayoutCode(CustomReportSelection,ReportSelections);
        if EmailBodyLayoutCode <> '' then begin
          TempReportLayoutCode := ReportLayoutSelection.GetTempLayoutSelected;
          ReportLayoutSelection.SetTempLayoutSelected(EmailBodyLayoutCode);
          ReportRecordVariant := DataRecRef;

          TempEmailBodyFilePath := CreateReportWithExtension(ReportRecordVariant,ReportID,REPORTFORMAT::Html,FileName);
          if TempEmailBodyFilePath = '' then
            exit;
          ReportLayoutSelection.SetTempLayoutSelected(TempReportLayoutCode);
        end;

        if SupressOutput or RemoveEmptyFile(TempPdfFilePath) then
          exit;

        AnyOutputExists := true;
        TryEmailReport(TempPdfFilePath,PdfFileName,TempEmailBodyFilePath,CustomReportSelection,FieldRef2);
    end;

    local procedure PreviewReport(var DataRecRef: RecordRef;ReportID: Integer;CustomReportLayoutCode: Code[20])
    var
        File: File;
        FileStream: OutStream;
        FileName: Text;
        TempFilePath: Text;
        ReportSaved: Boolean;
    begin
        if IsWebClient or IsWordLayout(ReportID,CustomReportLayoutCode) then begin
          TempFilePath := FileManagement.ServerTempFileName('.docx');
          FileName := GenerateFileNameForReportLayout(ReportID,'.docx','');
          File.Create(TempFilePath);
          File.CreateOutStream(FileStream);
          ReportSaved := REPORT.SaveAs(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Word,FileStream,DataRecRef);
          File.Close;
          if FileManagement.ServerFileExists(TempFilePath) and ReportSaved and not RemoveEmptyFile(TempFilePath) then
            AddFileToClientZip(TempFilePath,FileName);
        end else
          if not SupressOutput then begin
            REPORT.Execute(ReportID,GetRequestParametersText(ReportID),DataRecRef);
            AnyOutputExists := true;
          end;
    end;

    local procedure SaveAsReport(var DataRecRef: RecordRef;ReportID: Integer;RepFormat: ReportFormat)
    var
        File: File;
        FileStream: OutStream;
        FileName: Text;
        Extension: Text;
        TempFilePath: Text;
        ReportSaved: Boolean;
        BasePath: Text;
    begin
        // Handle both 'save file' types of reports together - PDF and Excel
        case RepFormat of
          REPORTFORMAT::Excel:
            Extension := '.xlsx';
          REPORTFORMAT::Pdf:
            Extension := '.pdf';
          REPORTFORMAT::Word:
            Extension := '.docx';
          REPORTFORMAT::Xml:
            Extension := '.xml';
          else
            Error(OutputNotSupportedErr);
        end;

        // If no path was given (often during test runs), use a temp directory on the server
        if FileManagement.IsWindowsClient and (Path = '') then
          Path := FileManagement.ServerCreateTempSubDirectory;

        // If we're not on the web client, use the path that was selected for saving
        // In the web client, the path isn't used since we zip up the files and send them to the client
        if not IsWebClient then
          BasePath := Path;
        case ReportingType of
          ReportingType::Object:
            FileName := GenerateFileNameForReport(ReportID,Extension,BasePath,true);
          ReportingType::Layout:
            FileName := GenerateFileNameForReportLayout(ReportID,Extension,BasePath);
        end;

        TempFilePath := FileManagement.ServerTempFileName(Extension);
        File.Create(TempFilePath);
        File.CreateOutStream(FileStream);
        ReportSaved := REPORT.SaveAs(ReportID,GetRequestParametersText(ReportID),RepFormat,FileStream,DataRecRef);
        File.Close;

        if ReportSaved and not RemoveEmptyFile(TempFilePath) and FileManagement.ServerFileExists(TempFilePath) and not SupressOutput then
          if IsWebClient then
            AddFileToClientZip(TempFilePath,FileName)
          else begin
            FileManagement.DownloadToFile(TempFilePath,FileName);
            TempEraseFileNameValueBuffer.AddNewEntry(Format(TempFilePath,250),'');
            AnyOutputExists := true;
          end;
    end;

    local procedure GenerateFileNameForReport(ReportID: Integer;Extension: Text;FilePath: Text;IncludeLayoutName: Boolean): Text[250]
    var
        NameFieldRef: FieldRef;
        ObjectName: Text;
        Caption: Text;
    begin
        // If we're iterating through Customer or Vendor, get the appropriate name
        if GetNameFieldRef(IteratorRecordRef,NameFieldRef) then
          ObjectName := StrSubstNo('%1',NameFieldRef.Value);

        if IncludeLayoutName then begin
          Caption := GetTempLayoutReportCaption(ReportID);
          ObjectName := StrSubstNo('%1_%2',ObjectName,Caption);
        end;

        exit(GenerateFileName(ObjectName,ReportID,Extension,FilePath));
    end;

    local procedure GenerateFileNameForReportLayout(ReportID: Integer;Extension: Text;FilePath: Text): Text[250]
    begin
        // Get report caption if we're not on a custom layout, otherwise get the custom layout caption
        exit(GenerateFileName(GetTempLayoutReportCaption(ReportID),ReportID,Extension,FilePath));
    end;

    local procedure GenerateFileName(ObjectName: Text;ReportID: Integer;Extension: Text;FilePath: Text): Text
    var
        FileName: Text;
        EndDate: Text;
        ReportParameters: Text;
    begin
        ReportParameters := GetRequestParametersText(ReportID);

        if StrPos(Extension,'.') <> 1 then
          Extension := '.' + Extension;

        // We need to limit the file name - limit of other functions
        if (StrLen(ObjectName) + StrLen(FilePath)) >= 250 then
          ObjectName := Format(ObjectName,250 - StrLen(FilePath));

        // Fetch request page parameters
        EndDate := GetOptionValueFromRequestPage(ReportParameters,'EndDate');

        // Construct with the end date, if it exists. Format the object name to adhere to filename size limits
        if OutputFileBaseName = '' then
          OutputFileBaseName := 'Report';
        if EndDate <> '' then
          FileName := OutputFileBaseName + ' for ' + ObjectName + ' as of ' + EndDate + Extension
        else
          FileName := OutputFileBaseName + ' for ' + ObjectName + Extension;

        FileName := FileManagement.StripNotsupportChrInFileName(FileName);

        if FilePath <> '' then
          FileName := FileManagement.CombinePath(FilePath,FileName);

        exit(FileName);
    end;

    local procedure GetOptionValueFromRequestPage(ReportParameters: Text;OptionName: Text): Text
    begin
        exit(RequestPageParametersHelper.GetRequestPageOptionValue(OptionName,ReportParameters));
    end;

    procedure GetOptionValueFromRequestPageForReport(ReportID: Integer;OptionName: Text): Text
    begin
        // Given a report ID - get the option from the request parameters page
        if not TempBlobReqParamStore.Get(ReportID) then
          exit('');
        exit(GetOptionValueFromRequestPage(GetRequestParametersText(ReportID),OptionName));
    end;

    local procedure GetTempLayoutReportCaption(ReportID: Integer): Text
    var
        CustomReportLayout: Record "Custom Report Layout";
        AllObjWithCaption: Record AllObjWithCaption;
        ReportCaption: Text;
        CurrentCustomLayoutCode: Code[20];
    begin
        CurrentCustomLayoutCode := ReportLayoutSelection.GetTempLayoutSelected;
        if CurrentCustomLayoutCode = '' then begin
          AllObjWithCaption.Get(AllObjWithCaption."Object Type"::Report,ReportID);
          ReportCaption := AllObjWithCaption."Object Caption";
        end else begin
          CustomReportLayout.Get(CurrentCustomLayoutCode);
          ReportCaption := CustomReportLayout.Description;
        end;
        exit(ReportCaption);
    end;

    [Scope('Personalization')]
    procedure SetSavePath(SavePath: Text)
    begin
        // This allows us to set the path ahead of setting request parameters if we know it or need to set it ahead of time
        // e.g. for unit tests
        Path := SavePath;
    end;

    local procedure GetViewFromParameters(ReportID: Integer;TableNumber: Integer): Text
    var
        RecordRef: RecordRef;
    begin
        TempBlobReqParamStore.Get(ReportID);
        TempBlobReqParamStore.SetRecFilter;
        TempBlobReqParamStore.CalcFields(Blob);
        // Use the request page helper to parse the parameters and set the view to the RecordRef and the Record
        RecordRef.Open(TableNumber);
        RequestPageParametersHelper.ConvertParametersToFilters(RecordRef,TempBlobReqParamStore);

        exit(RecordRef.GetView);
    end;

    local procedure GetRequestParameters()
    var
        SMTPMailSetup: Record "SMTP Mail Setup";
        DataVariant: Variant;
        TempReqParams: Text;
        FilterGroup: Integer;
    begin
        ReportSelections.SetFilter("Report ID",'<>0');
        ReportSelections.FindFirst;

        if ReportSelections.FindSet then
          repeat
            // If we're at this point, and we're set in test mode with XML output - run the report directly from here
            // This is done to retain compatibility with report testing (which uses RequestPage.SaveAsXML and needs the traditional output options buttons)
            // XML output can't use the layouts anyways.
            if IsTestMode and OverrideOutput and (OutputType = OutputType::XML) then begin
              DataVariant := ReportDataRecordRef;
              REPORT.RunModal(ReportSelections."Report ID",true,false,DataVariant);
              Error(''); // Exit early in an uninitialized state, prevents the full initialization flag from being set
            end;
            Commit;
            TempReqParams :=
              REPORT.RunRequestPage(ReportSelections."Report ID",GetReportRequestPageParameters(ReportSelections."Report ID"));
            // If the user cancelled out of the request page - exclude this report ID from processing:
            if TempReqParams = '' then begin
              // Advance to the next open filtergroup outside of the system range
              FilterGroup := ReportSelections.FilterGroup;
              if ReportSelections.HasFilter or (ReportSelections.FilterGroup < 10) then
                repeat
                  ReportSelections.FilterGroup(ReportSelections.FilterGroup + 1)
                until not ReportSelections.HasFilter and (ReportSelections.FilterGroup >= 10);
              ReportSelections.SetFilter("Report ID",StrSubstNo('<>%1',ReportSelections."Report ID"));
              ReportSelections.FilterGroup(FilterGroup);
              break;
            end;

            StoreRequestParameters(TempReqParams);
            SaveReportRequestPageParameters(ReportSelections."Report ID",TempReqParams);
            // Validate output type and get a file save path, if necessary, only prompt for windows clients that are not in test mode
            SetOutputType(ReportSelections."Report ID");
            if FileManagement.IsWindowsClient and (Path = '') and (not IsTestMode) and
               (OutputType in [OutputType::PDF,OutputType::Excel,OutputType::Word,OutputType::XML])
            then
              FileManagement.SelectFolderDialog(SaveFolderMsg,Path);

            // Use the temp path if we're set in test mode and the path wasn't already set
            if (Path = '') and IsTestMode then
              Path := TemporaryPath;

            // If email is chosen, ensure that SMTP is set up
            if (OutputType = OutputType::Email) and not SMTPMailSetup.GetSetup and not SupressOutput then
              Error(SMTPNotSetupErr);
          until ReportSelections.Next = 0;

        Initialized := true;
    end;

    local procedure SetOutputType(ReportID: Integer)
    var
        OutputMethod: Text;
        OptionInt: Integer;
    begin
        // Don't set based on the report ID if we're overriding the output type (for tests, output-specific functions)
        if OverrideOutput then
          exit;
        // The request page should have the appropriate parameters set for the chosen output method
        OutputMethod := GetOptionValueFromRequestPage(GetRequestParametersText(ReportID),'ChosenOutputMethod');
        if OutputMethod <> '' then begin
          if not Evaluate(OptionInt,OutputMethod) then
            Error(OutputNotSupportedErr);
        end else
          Error(OutputNotSupportedErr);

        SetOutputOption(OptionInt);
    end;

    local procedure SetReportUsage(ReportSelectionUsage: Integer)
    begin
        ReportSelections.SetRange(Usage,ReportSelectionUsage);
        CustomReportSelection.SetRange(Usage,ReportSelectionUsage);
    end;

    [Scope('Personalization')]
    procedure SetOutputSupression(SupressOutputFlag: Boolean)
    begin
        SupressOutput := SupressOutputFlag;
    end;

    local procedure StoreRequestParameters(Parameters: Text)
    var
        OutStr: OutStream;
        ReportID: Integer;
    begin
        Evaluate(ReportID,RequestPageParametersHelper.GetReportID(Parameters));
        // Insert or Modify - based on if it exists already or not
        if TempBlobReqParamStore.Get(ReportID) then begin
          TempBlobReqParamStore.Blob.CreateOutStream(OutStr);
          OutStr.WriteText(Parameters);
          TempBlobReqParamStore.Modify;
        end else begin
          TempBlobReqParamStore.Init;
          TempBlobReqParamStore.Blob.CreateOutStream(OutStr);
          OutStr.WriteText(Parameters);
          TempBlobReqParamStore."Primary Key" := ReportID;
          TempBlobReqParamStore.Insert;
        end;
        Commit;
    end;

    local procedure GetRequestParametersText(ReportID: Integer): Text
    var
        InStr: InStream;
        ReqPageXML: Text;
    begin
        TempBlobReqParamStore.Get(ReportID);
        TempBlobReqParamStore.CalcFields(Blob);
        TempBlobReqParamStore.Blob.CreateInStream(InStr);
        InStr.ReadText(ReqPageXML);
        exit(ReqPageXML);
    end;

    local procedure AddFileToClientZip(TempFileName: Text;ClientFileName: Text)
    begin
        if StrLen(TempFileName) > 250 then
          Error(PathLengthErr,TempFileName);

        if StrLen(ClientFileName) > 250 then
          Error(PathLengthErr,ClientFileName);

        // Ensure we have a zip file object
        if ZipFileName = '' then
          ZipFileName := FileManagement.CreateZipArchiveObject;

        TempNameValueBuffer.SetRange(Name,CopyStr(ClientFileName,1,250));
        if not TempNameValueBuffer.FindFirst then
          TempNameValueBuffer.AddNewEntry(CopyStr(ClientFileName,1,250),CopyStr(TempFileName,1,250));

        AnyOutputExists := true;
    end;

    local procedure IsWordLayout(ReportID: Integer;CustomReportLayoutCode: Code[20]): Boolean
    var
        CustomReportLayout: Record "Custom Report Layout";
    begin
        if CustomReportLayoutCode <> '' then begin
          CustomReportLayout.Code := CustomReportLayoutCode;
          if CustomReportLayout.Find('=') then
            exit(CustomReportLayout.Type = CustomReportLayout.Type::Word);

          exit(REPORT.DefaultLayout(ReportID) = DEFAULTLAYOUT::Word);
        end;
        exit(REPORT.DefaultLayout(ReportID) = DEFAULTLAYOUT::Word)
    end;

    local procedure SetReportDataItem(var DataRecordRef: RecordRef;SourceJoinFieldName: Text;DataRecordJoinTable: Integer;IteratorTableFieldName: Text;DataItemTableSameAsIterator: Boolean)
    var
        "Field": Record "Field";
        TypeHelper: Codeunit "Type Helper";
        ConfigValidateManagement: Codeunit "Config. Validate Management";
        RelationTable: Integer;
        RelationField: Integer;
    begin
        // Copy the RecordRef so as to not disturb the original
        ReportDataRecordRef := DataRecordRef.Duplicate;

        // Find the fields that relate the iterator to the data record - based on caption:
        Field.SetRange(FieldName,SourceJoinFieldName);
        if TypeHelper.FindFields(ReportDataRecordRef.Number,Field) then
          ReportDataIteratorFieldRef := ReportDataRecordRef.Field(Field."No.");
        // If the tables are different, 'join' using the filter of the data item passed in.
        if DataItemTableSameAsIterator then begin
          IteratorRecordRef.Open(ReportDataRecordRef.Number);
          IteratorJoinFieldRef := IteratorRecordRef.Field(ReportDataIteratorFieldRef.Number);
          SetNextGroupFilter(IteratorRecordRef,IteratorJoinFieldRef,ReportDataIteratorFieldRef.GetFilter);
          ReportDataAndIteratorDiffer := false;
        end else begin
          ConfigValidateManagement.GetRelationInfoByIDs(
            ReportDataRecordRef.Number,ReportDataIteratorFieldRef.Number,RelationTable,RelationField);
          IteratorRecordRef.Open(DataRecordJoinTable);
          Field.Reset;
          Field.SetRange(FieldName,IteratorTableFieldName);
          if TypeHelper.FindFields(IteratorRecordRef.Number,Field) then
            IteratorJoinFieldRef := IteratorRecordRef.Field(Field."No.");
          ReportDataAndIteratorDiffer := true;
        end;

        CustomReportSelection.SetRange("Source Type",IteratorRecordRef.Number);
    end;

    local procedure RemoveEmptyFile(FileName: Text): Boolean
    var
        File: File;
    begin
        // This function cleans up empty files, allowing us to remove reports that do not save correctly or error out/have no output.
        File.Open(FileName);
        if File.Len = 0 then begin
          File.Close;
          Erase(FileName);
          exit(true);
        end;
        File.Close;
        exit(false);
    end;

    procedure IsWebClient(): Boolean
    begin
        if TestModeWebClient then
          exit(true);
        exit(FileManagement.IsWebClient);
    end;

    procedure SetOutputFileBaseName(FileBaseName: Text)
    begin
        // Sets a text base name for the output files:
        // e.g. code calling reports with usage of 'Statement' would set 'Statement' here
        OutputFileBaseName := FileBaseName;
    end;

    [Normal]
    procedure SetTestMode(TestMode: Boolean)
    var
        TempBlob: Record TempBlob;
        BlobOutStream: OutStream;
    begin
        // Sets test mode for this codeunit - enables unit test scenarios
        TempBlob.Init;
        TempBlob.Reset;
        TempBlob."Primary Key" := CODEUNIT::"Custom Layout Reporting";
        if TempBlob.Find then
          TempBlob.Delete;

        TempBlob.Blob.CreateOutStream(BlobOutStream);
        BlobOutStream.WriteText(Format(TestMode));
        TempBlob.Insert;
        Commit;

        OverrideOutput := TestMode;
    end;

    local procedure IsTestMode(): Boolean
    var
        TempBlob: Record TempBlob;
        TestModeInStream: InStream;
        ReadText: Text[10];
        ReadBoolean: Boolean;
    begin
        // Check to see if the test mode flag is set (usually via test codeunits before calling this codeunit directly)
        // Alternatively, check tempblob for a sentinel value (set via test codeunits that do not/cannot call this codeunit directly)
        ReadBoolean := false;
        if TempBlob.Get(8800) then begin
          TempBlob.CalcFields(Blob);
          TempBlob.Blob.CreateInStream(TestModeInStream);
          TestModeInStream.ReadText(ReadText,10);
          Evaluate(ReadBoolean,ReadText);
        end;
        exit(ReadBoolean);
    end;

    procedure SetTestModeWebClient(TestModeSpoofWebClient: Boolean)
    begin
        TestModeWebClient := TestModeSpoofWebClient;
    end;

    local procedure ResolveCustomReportLayoutCode(var CustomReportSelection: Record "Custom Report Selection"): Code[20]
    begin
        // Given a custom report selection, return the custom layout, unless report ID  = 0, then resolve to the appropriate company-wide layout for the report ID
        if CustomReportSelection."Custom Report Layout Code" <> '' then
          exit(CustomReportSelection."Custom Report Layout Code");

        // If we don't have a custom layout defined in this selection record, get the default for the report number
        if ReportLayoutSelection.Get(CustomReportSelection."Report ID",CompanyName) then
          exit(ReportLayoutSelection."Custom Report Layout Code");

        exit(''); // We haven't found any custom report layouts
    end;

    local procedure ResolveEmailBodyLayoutCode(var CustomReportSelection: Record "Custom Report Selection";var ReportSelections: Record "Report Selections"): Code[20]
    begin
        if CustomReportSelection."Use for Email Body" then
          exit(CustomReportSelection."Email Body Layout Code");

        if ReportSelections."Use for Email Body" then
          exit(ReportSelections."Email Body Layout Code");

        exit(''); // We haven't found any custom report layouts
    end;

    procedure InitializeData(ReportSelectionUsage: Integer;var DataRecordRef: RecordRef;SourceJoinFieldName: Text;DataRecordJoinTable: Integer;IteratorTableFieldName: Text;DataItemTableSameAsIterator: Boolean)
    begin
        // Initialize parameters and request pages, but do not run the reports yet
        SetReportUsage(ReportSelectionUsage);
        SetReportDataItem(DataRecordRef,SourceJoinFieldName,DataRecordJoinTable,IteratorTableFieldName,DataItemTableSameAsIterator);
        GetRequestParameters;
    end;

    [Scope('Personalization')]
    procedure HasRequestParameterData(ReportID: Integer): Boolean
    begin
        // Allows the caller to determine if valid request parameters XML is stored for the given report ID.
        // This is mostly useful to determine if a given report's request page has been canceled or not.
        exit(TempBlobReqParamStore.Get(ReportID));
    end;

    local procedure GetKeyFieldRef(var TableRecordRef: RecordRef;var KeyFieldRef: FieldRef): Boolean
    var
        DataTypeManagement: Codeunit "Data Type Management";
    begin
        case TableRecordRef.Number of
          DATABASE::Customer,
          DATABASE::Vendor:
            begin
              DataTypeManagement.FindFieldByName(TableRecordRef,KeyFieldRef,'No.');
              exit(true);
            end;
          else
            exit(false);
        end;
    end;

    local procedure GetNameFieldRef(var TableRecordRef: RecordRef;var NameFieldRef: FieldRef): Boolean
    var
        DataTypeManagement: Codeunit "Data Type Management";
    begin
        case TableRecordRef.Number of
          DATABASE::Customer,
          DATABASE::Vendor:
            begin
              DataTypeManagement.FindFieldByName(TableRecordRef,NameFieldRef,'Name');
              exit(true);
            end;
          else
            exit(false);
        end;
    end;

    local procedure FindNextEmptyFilterGroup(var RecordRef: RecordRef): Integer
    var
        FilterGroup: Integer;
        StartingGroup: Integer;
    begin
        // Finds the next empty filter group, with a minimum of group 10 to ensure we're in a non-system group.
        StartingGroup := RecordRef.FilterGroup;
        FilterGroup := StartingGroup;

        if FilterGroup < 10 then
          FilterGroup := 10;

        // Find the next empty group
        RecordRef.FilterGroup(FilterGroup);
        if RecordRef.HasFilter then
          repeat
            FilterGroup += 1;
            RecordRef.FilterGroup(FilterGroup);
          until not RecordRef.HasFilter;

        // Reset the group back to the original value
        RecordRef.FilterGroup(StartingGroup);

        exit(FilterGroup);
    end;

    local procedure SetNextGroupFilter(var RecordRef: RecordRef;var FieldRef: FieldRef;"Filter": Text): Integer
    var
        NextGroup: Integer;
    begin
        NextGroup := FindNextEmptyFilterGroup(RecordRef);
        SetGroupFilter(RecordRef,FieldRef,Filter,NextGroup);
        exit(NextGroup);
    end;

    local procedure SetGroupFilter(var RecordRef: RecordRef;var FieldRef: FieldRef;"Filter": Text;GroupNumber: Integer)
    var
        FilterGroup: Integer;
    begin
        FilterGroup := RecordRef.FilterGroup;
        RecordRef.FilterGroup(GroupNumber);
        FieldRef.SetFilter(Filter);
        RecordRef.FilterGroup(FilterGroup);
    end;

    local procedure CleanupTempFiles()
    var
        DeleteError: Boolean;
    begin
        // Sometimes file handles are kept by .NET - we try to delete what we can.
        if TempEraseFileNameValueBuffer.FindSet then
          repeat
            if not TryDeleteFile(TempEraseFileNameValueBuffer.Name) then
              DeleteError := true;
          until TempEraseFileNameValueBuffer.Next = 0;

        if DeleteError then
          Error('');
    end;

    [TryFunction]
    local procedure TryDeleteFile(FileName: Text)
    begin
        FileManagement.DeleteServerFile(FileName);
    end;

    [TryFunction]
    local procedure TryCreateFileStream(var File: File;ReportID: Integer;var TempFilePath: Text[250];var FileName: Text[250];var FileStream: OutStream;Extension: Text)
    var
        FileManagement: Codeunit "File Management";
    begin
        TempFilePath := CopyStr(FileManagement.ServerTempFileName(Extension),1,250);

        FileName := GenerateFileNameForReport(ReportID,Extension,'',false);

        File.Create(TempFilePath);
        File.CreateOutStream(FileStream);
    end;

    [TryFunction]
    local procedure TryEmailReport(TempFilePath: Text[250];FileName: Text[250];TempEmailBodyFilePath: Text[250];var CustomReportSelection: Record "Custom Report Selection";var FieldRef2: FieldRef)
    var
        DocumentMailing: Codeunit "Document-Mailing";
    begin
        DocumentMailing.EmailFile(
          CopyStr(TempFilePath,1,250),FileName,TempEmailBodyFilePath,'',CustomReportSelection."Send To Email",
          StrSubstNo('%1',FieldRef2.Value),true,CustomReportSelection.Usage);
        if Exists(TempFilePath) then
          TempEraseFileNameValueBuffer.AddNewEntry(TempFilePath,'');
        if Exists(TempEmailBodyFilePath) then
          TempEraseFileNameValueBuffer.AddNewEntry(TempEmailBodyFilePath,'');
    end;

    local procedure CreateReportWithExtension(var DataRecRef: RecordRef;ReportID: Integer;ReportFormatType: ReportFormat;var FileName: Text[250]): Text[250]
    var
        File: File;
        FileStream: OutStream;
        TempFilePath: Text[250];
    begin
        case ReportFormatType of
          REPORTFORMAT::Pdf:
            begin
              TryCreateFileStream(File,ReportID,TempFilePath,FileName,FileStream,'pdf');
              TempEmailNameValueBuffer.SetRange(Name,FileName);
              if not TempEmailNameValueBuffer.FindFirst then
                if REPORT.SaveAs(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Pdf,FileStream,DataRecRef) then begin
                  TempEmailNameValueBuffer.AddNewEntry(CopyStr(FileName,1,250),CopyStr(TempFilePath,1,250));
                  File.Close;
                  exit(TempFilePath);
                end;
              File.Close;
              exit('');
            end;
          REPORTFORMAT::Html:
            begin
              TryCreateFileStream(File,ReportID,TempFilePath,FileName,FileStream,'html');
              TempEmailNameValueBuffer.SetRange(Name,FileName);
              if not TempEmailNameValueBuffer.FindFirst then
                if REPORT.SaveAs(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Html,FileStream,DataRecRef) then begin
                  TempEmailNameValueBuffer.AddNewEntry(CopyStr(FileName,1,250),CopyStr(TempFilePath,1,250));
                  File.Close;
                  exit(TempFilePath);
                end;
              File.Close;
              exit('');
            end;
          else
            Error(ReportFormatNotSupportedErr,ReportFormatType);
        end;
    end;

    local procedure SetIteratorJoinFieldRef()
    var
        Vendor: Record Vendor;
        Customer: Record Customer;
        GenJournalLine: Record "Gen. Journal Line";
        IteratorTableFieldName: Text;
        i: Integer;
        DataRecordJoinTable: Integer;
    begin
        BalAcctTypeFieldRef := ReportDataRecordRef.Field(63);
        AcctTypeFieldRef := ReportDataRecordRef.Field(3);

        case Format(BalAcctTypeFieldRef.Value) of
          Format(GenJournalLine."Bal. Account Type"::Vendor):
            begin
              DataRecordJoinTable := DATABASE::Vendor;
              IteratorTableFieldName := Vendor.FieldName("No.");
            end;
          Format(GenJournalLine."Bal. Account Type"::Customer):
            begin
              DataRecordJoinTable := DATABASE::Customer;
              IteratorTableFieldName := Customer.FieldName("No.");
            end;
          Format(GenJournalLine."Bal. Account Type"::"Bank Account"):
            case Format(AcctTypeFieldRef.Value) of
              Format(GenJournalLine."Account Type"::Customer):
                begin
                  DataRecordJoinTable := DATABASE::Customer;
                  IteratorTableFieldName := Customer.FieldName("No.");
                end;
              Format(GenJournalLine."Account Type"::Vendor):
                begin
                  DataRecordJoinTable := DATABASE::Vendor;
                  IteratorTableFieldName := Vendor.FieldName("No.");
                end;
            end;
        end;
        if DataRecordJoinTable <> 0 then begin
          IteratorRecordRef.Close;
          IteratorRecordRef.Open(DataRecordJoinTable);
          for i := 1 to IteratorRecordRef.FieldCount do
            if IteratorRecordRef.Field(i).Name = IteratorTableFieldName then begin
              IteratorJoinFieldRef := IteratorRecordRef.Field(i);
              break;
            end;
        end;
    end;

    local procedure GetReportRequestPageParameters(ReportID: Integer) XMLTxt: Text
    var
        ObjectOptions: Record "Object Options";
        InStr: InStream;
    begin
        if not ObjectOptions.Get(LastUsedTxt,ReportID,ObjectOptions."Object Type"::Report,UserId,CompanyName) then
          exit('');
        ObjectOptions.CalcFields("Option Data");
        ObjectOptions."Option Data".CreateInStream(InStr);
        InStr.ReadText(XMLTxt);
        exit(XMLTxt);
    end;

    local procedure SaveReportRequestPageParameters(ReportID: Integer;XMLText: Text)
    var
        ObjectOptions: Record "Object Options";
        OutStr: OutStream;
    begin
        if XMLText = '' then
          exit;

        with ObjectOptions do begin
          if Get(LastUsedTxt,ReportID,"Object Type"::Report,UserId,CompanyName) then
            Delete;
          Init;
          "Parameter Name" := LastUsedTxt;
          "Object Type" := "Object Type"::Report;
          "Object ID" := ReportID;
          "User Name" := UserId;
          "Company Name" := CompanyName;
          "Created By" := UserId;
          "Option Data".CreateOutStream(OutStr);
          OutStr.WriteText(XMLText);
          Insert;
        end;
    end;
}

